from flask import Flask, request, render_template, redirect, session
from sqlalchemy import create_engine, Column, ForeignKey, Integer, String, DateTime, Boolean, Float, Enum, text
import os
from sqlalchemy.orm import sessionmaker, relationship
from sqlalchemy.ext.declarative import declarative_base
from datetime import datetime

from flask_wtf import FlaskForm
from wtforms import StringField, PasswordField, SelectField, HiddenField
from wtforms.validators import DataRequired

app = Flask(__name__)

app.secret_key = 'your_secret_key_here'

#connecting to the database
db_connection_string = os.environ['DB_CONNECTION_STRING']

engine = create_engine(db_connection_string,
                       connect_args={"ssl": {
                         "ssl_ca": "/etc/ssl/cert.pem"
                       }})
Session = sessionmaker(bind=engine)
session0 = Session()
Base = declarative_base()

#Models


# Models
class User(Base):
    __tablename__ = 'users'

    user_id = Column(Integer, primary_key=True, autoincrement=True)
    username = Column(String(255), unique=True, nullable=False)
    user_password = Column(String(255), nullable=False)
    user_role = Column(Enum('admin', 'student', 'professor'), nullable=False)
    f_name = Column(String(100), nullable=False)
    l_name = Column(String(100), nullable=False)

    professor = relationship('Professor', uselist=False, backref='user', cascade="all, delete")
    students = relationship('Student', backref='user', cascade="all, delete")


class Professor(Base):
    __tablename__ = 'professors'

    user_id = Column(Integer, ForeignKey('users.user_id'), primary_key=True)
    degree = Column(String(255), nullable=False)
    specialization = Column(String(255), nullable=False)


class Student(Base):
    __tablename__ = 'students'

    user_id = Column(Integer, ForeignKey('users.user_id'), primary_key=True)
    class_id = Column(Integer, ForeignKey('classes.id'), nullable=False)
    class_ = relationship('Class', backref='students')


class Class(Base):
    __tablename__ = 'classes'

    id = Column(Integer, primary_key=True, autoincrement=True)
    class_name = Column(String(255), unique=True, nullable=False)
    class_field = Column(String(255), nullable=False)
    class_level = Column(Integer, nullable=False)



query = '''
    SELECT users.username, users.f_name, users.l_name, classes.class_name
    FROM users
    JOIN students ON users.user_id = students.user_id
    JOIN classes ON students.class_id = classes.id
'''

result = session0.execute(text(query))

students = []
for row in result:
    username, f_name, l_name, class_name = row
    students.append((username, f_name, l_name, class_name))
  
print(students)









def add_question_to_database(quiz_id, question_content, options_data):
    # Create a new Question instance and add it to the database
    new_question = Question(quiz_id=quiz_id, q_content=question_content)
    session0.add(new_question)
    session0.commit()

    # Retrieve the question ID (assuming the primary key is auto-incremented)
    question_id = new_question.q_id

    # Create Option instances and add them to the database
    for option_content, is_correct in options_data:
        new_option = Option(question_id=question_id, o_content=option_content, is_correct=is_correct)
        session0.add(new_option)

    # Commit the changes to the database
    session0.commit()





<h2>Options:</h2>
        {% for option in form.options %}
            <div>
                {{ option.option_content.label }}: {{ option.option_content() }}
                {{ option.is_correct.label }}: {{ option.is_correct() }}
            </div>
        {% endfor %}
        <br>



@app.route('/create_question/<int:quiz_id>', methods=['GET', 'POST'])
def create_question(quiz_id):
    quiz = session0.query(Quiz).get(quiz_id)
    if not quiz:
        return "Quiz not found", 404

    form = QuestionForm()
    if form.validate_on_submit():
        # Step 1: Save the question to the database
        question = Question(quiz_id=quiz_id, q_content=form.question_content.data)
        session0.add(question)
        session0.commit()

        # Step 2: Retrieve the question_id (q_id) generated by the database
        question_id = question.q_id

        # Step 3: Save the options associated with the question
        for option_form in form.options:
            if option_form.option_content.data:
                option = Option(
                    question_id=question_id,
                    o_content=option_form.option_content.data,
                    is_correct=option_form.is_correct.data
                )
                session0.add(option)

        session0.commit()
        return redirect(url_for('create_question', quiz_id=quiz_id))

    return render_template('create_question.html', form=form, quiz=quiz, quiz_id=quiz_id)
